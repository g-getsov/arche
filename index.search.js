var relearn_search_index = [
  {
    "breadcrumb": "Arche",
    "content": "This page shows how to install Arche, and gives a minimal usage example.\nFinally, it points into possible directions to continue.\nInstallation Usage example What‚Äôs next? Installation To use Arche in a Go project, run:\n1go get github.com/mlange-42/archeUsage example Here is the classical Position/Velocity example that every ECS shows in the docs. It uses the type-safe generic API.\n1package main 2 3import ( 4\t\"math/rand\" 5 6\t\"github.com/mlange-42/arche/ecs\" 7\t\"github.com/mlange-42/arche/generic\" 8) 9 10// Position component 11type Position struct { 12\tX float64 13\tY float64 14} 15 16// Velocity component 17type Velocity struct { 18\tX float64 19\tY float64 20} 21 22func main() { 23\t// Create a World. 24\tworld := ecs.NewWorld() 25 26\t// Create a component mapper. 27\tmapper := generic.NewMap2[Position, Velocity](\u0026world) 28 29\t// Create entities. 30\tfor i := 0; i \u003c 1000; i++ { 31\t// Create a new Entity with components. 32\tentity := mapper.New() 33\t// Get the components 34\tpos, vel := mapper.Get(entity) 35\t// Initialize component fields. 36\tpos.X = rand.Float64() * 100 37\tpos.Y = rand.Float64() * 100 38\tvel.X = rand.NormFloat64() 39\tvel.Y = rand.NormFloat64() 40\t} 41 42\t// Create a generic filter. 43\tfilter := generic.NewFilter2[Position, Velocity]() 44 45\t// Time loop. 46\tfor t := 0; t \u003c 1000; t++ { 47\t// Get a fresh query. 48\tquery := filter.Query(\u0026world) 49\t// Iterate it 50\tfor query.Next() { 51\t// Component access through the Query. 52\tpos, vel := query.Get() 53\t// Update component fields. 54\tpos.X += vel.X 55\tpos.Y += vel.Y 56\t} 57\t} 58} What‚Äôs next? If you ask ‚ÄúWhat is ECS?‚Äù, take a look at the great ECS FAQ by Sander Mertens, the author of the Flecs ECS.\nTo learn how to use Arche, read the User Guide, browse the API documentation, or take a look at the examples in the GitHub repository.\nYou can also read about Arche‚Äôs Design Philosophy and Architecture for more background information.\nSee the Benchmarks if you are interested in some numbers on Arche‚Äôs performance.\n",
    "description": "Quickstart guide to install and use Arche.",
    "tags": null,
    "title": "Quickstart",
    "uri": "/quickstart/index.html"
  },
  {
    "breadcrumb": "Arche",
    "content": "Arche‚Äôs user guide.\nUsage The following chapters are designed to be read sequentially in the presented order. If you are familiar with ECS and know what you are looking for, you may also just look it up or use the search.\nIf you are not familiar with the Entity Component System (ECS) concept, take a look at the great ECS FAQ by Sander Mertens, the author of the Flecs ECS.\nTip Inline code referencing Arche's API is linked to the API reference, like here: ecs.World . ",
    "description": "Comprehensive Arche user guide.",
    "tags": null,
    "title": "User Guide",
    "uri": "/guide/index.html"
  },
  {
    "breadcrumb": "Arche",
    "content": "Background information on Arche‚Äôs design, architecture, performance and history.\n",
    "description": "Background information on Arche's design, architecture, performance and history.",
    "tags": null,
    "title": "Background",
    "uri": "/background/index.html"
  },
  {
    "breadcrumb": "Arche",
    "content": "If you made something using Arche and would like to see it here, feel free to open an issue or start a discussion in the GitHub repository.\nTiny World A tiny, slow-paced world and colony building game. Arche Demo Demo models and visualizations for Arche. ",
    "description": "Projects using Arche.",
    "tags": null,
    "title": "Made with Arche",
    "uri": "/made_with/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†Background",
    "content": "Unlike most other ECS implementations, Arche is designed for the development of scientific, individual-based models rather than for game development. This motivates some design decisions, with an emphasis on simplicity, safety and performance. Nevertheless, Arche can also be used for game development.\nSimple core API Determinism Strict and panic Limitations Simple core API The ecs.World object is a pure and simple ECS implementation in the sense of a data store for entities and components, with query and iteration capabilities. More advanced features like batch operations or entity relations are provided through separate objects.\nThere is neither an update loop nor systems. These should be implemented by the user. For a batteries-included implementation, see module arche-model.\nThe packages filter and generic provide a layer around the core for richer resp. generic queries and manipulation. They are built on top of the ecs package, so they could also be implemented by a user.\nDeterminism Iteration order in Arche is deterministic and reproducible. This does not mean that entities are iterated in their order of insertion, nor in the same order in successive iterations. However, given the same operations on the ecs.World , iteration order will always be the same.\nStrict and panic Arche puts an emphasis on safety and on avoiding undefined behavior. It panics on unexpected operations, like removing a dead entity, adding a component that is already present, or attempting to change a locked world. This may not seem idiomatic for Go. However, explicit error handling in performance hotspots is not an option. Neither is silent failure, given the scientific background.\nLimitations The number of component types per World is limited to 256. This is mainly a performance decision. The number of entities alive at any one time is limited to just under 5 billion (uint32 ID). ",
    "description": "Specific design considerations behind Arche.",
    "tags": null,
    "title": "Design Philosophy",
    "uri": "/background/design/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†User Guide",
    "content": "Arche provides two different APIs:\nA generic API that is often the most convenient. But perhaps more importantly, it is type safe. It is the recommended way of usage for most users.\nAn ID-based API that is slightly faster than the generic one in some places. Further, it is more flexible and may be more appropriate for tasks like automated serialization.\nBoth APIs can be mixed as needed.\nTip In this user guide, most code examples will be presented with two tabs, one for each API: ‚Äã generic ID-based 1world := ecs.NewWorld() 2 3filter := generic.NewFilter2[Position, Velocity]() 4 5query := filter.Query(\u0026world) 6for query.Next() { 7\tpos, vel := query.Get() 8\tpos.X += vel.X 9\tpos.Y += vel.Y 10} 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4velID := ecs.ComponentID[Velocity](\u0026world) 5filter := ecs.All(posID, velID) 6 7query := world.Query(filter) 8for query.Next() { 9\tpos := (*Position)(query.Get(posID)) 10\tvel := (*Velocity)(query.Get(posID)) 11\tpos.X += vel.X 12\tpos.Y += vel.Y 13} ",
    "description": "Overview of Arche's generic and ID-based APIs.",
    "tags": null,
    "title": "Generic \u0026 ID-based API",
    "uri": "/guide/apis/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†Background",
    "content": "Arche uses an archetype-based architecture. Therefore the name üòâ.\nThis chapter explains the concept and Arche‚Äôs take on it.\nArchetypes World entity access Performance Details Archetype graph Entity relations Archetype removal Archetypes The ASCII graph below illustrates the approach. Components for entities are stored in so-called archetypes. Archetypes represent unique combinations of components. This means that component data for all entities with exactly the same component is stored in the same archetype.\nIn the illustration below, the first archetype holds entities with (only/exactly) the components A, B and C, as well as their components. Similarly, the second archetype contains all entities with A and C, and their components.\n1 Entities Archetypes Bit masks Queries 2 3 E E Comps 4 |0| |2|A|B|C| 111... \u003c-. \u003c---. 5 |1|---. |8|A|B|C| | | 6 |2| '--\u003e|1|A|B|C| | | 7 |3| |3|A|B|C| |--Q(A,C) | 8 |4| | 101... | 9 |6| .--\u003e|7|A|C| 101... \u003c-' |--Q(B) 10 |7|---' |6|A|C| | 010... 11 |8| |4|A|C| | 12 |9|---. | 13 |.| | |5|B|C| 011... \u003c---' 14 |.| '--\u003e|9|B|C| 15 |.| 16 |.| \u003c===\u003e [Entity pool]Illustration of Arche‚Äôs archetype-based architecture.\nThe exact component composition of each archetype is encoded in a bitmask for fast comparison. Thus, queries can easily identify their relevant archetypes, and then simply iterate entities linearly, which is very fast and cache-friendly. Components can be accessed through a query in a very efficiently (‚âà1ns).\nWorld entity access For getting components by entity, e.g. for hierarchies, the world contains a list that is indexed by the entity ID (left-most in the figure). For each entity, it references its current archetype and the position of the entity in the archetype. This way, getting components for entities (i.e. random access) is fast, although not as fast as in queries (‚âà2ns vs. 1ns).\nNote that the entities list also contains entities that are currently not alive, because they were removed. These entities are recycled when new entities are requested from the ecs.World . Therefore, besides the ID shown in the illustration, each entity also has a generation variable. It is incremented on each ‚Äúreincarnation‚Äù of an entity. Thus, it allows to distinguish recycled from dead entities, as well as from previous or later ‚Äúincarnations‚Äù.\nPerformance Obviously, archetypes are an optimization for iteration speed. But they also come with a downside. Adding or removing components to/from an entity requires moving all the components of the entity to another archetype. This takes roughly 10-20ns per involved component. To reduce the number of archetype changes, it is recommended to add/remove/exchange multiple components at the same time rather than one after the other.\nHowever, as the benchmarks on the repo README illustrate, Arche seems to be the fastest Go ECS available. Not only in terms of iteration speed, which is particularly tailored for. Even when it comes to entity manipulation (adding, removing components etc.), where sparse-set ECS implementations should shine, Arche leads the field.\nFor more numbers on performance, see chapter Benchmarks.\nDetails Actually, the explanation above is quite simplified. Particularly it leaves out Entity Relations and the archetypes graph and nodes.\nArchetype graph When components are added to or removed from an entity, it is necessary to find its new archetype. To accelerate the search, a graph of archetype nodes (or just nodes) is used. The figure below illustrates the concept. Each arrow represents the transition between two archetypes when a single component is added (solid arrow head) or removed (empty arrow head). Following these transitions, the archetype resulting from addition and/or removal of an arbitrary number of components can be found easily.\nIllustration of the archetype graph. Letters represent components. Boxes represent archetype nodes. Arrows represent transitions when a single component is added or removed.\nNodes and connections are created as needed. When searching for an archetype, the algorithm proceeds transition by transition. When looking for the next archetype, established transitions are checked first. If this is not successful, the resulting component mask is used to search through all nodes. On success, a new connection is established. If the required node was still not found, a new node is created. Then, the next transition it processed and so on, until the final node is found. Only then, an archetype is created for the node.\nAs a result, the graph will in most cases not be fully connected. There will also not be all possible nodes (combinations of components) present. Nodes that are only traversed by the search but never receive entities contain no archetype and are called inactive.\nThe graph stabilizes quickly. Then, only the fast following of transitions is required to find an archetype when components are added or removed. Transitions are stored in the nodes with lookup approx. 10 times faster than Go‚Äôs map.\nEntity relations The archetype nodes explained above are utilized to implement Arche‚Äôs Entity Relations feature. When an archetype contains a relation components, the respective node contains an archetype ‚Äútable‚Äù for each entity that is a target of that relation. As an example, we have components A, B and R, where R is a relation. Further, we have two parent entities E1 and E2. When you create some entities with components A B R(E1) and A B R(E2), i.e. with relation targets E1 and E2, the following node is created:\n1 Node [ A B R ] 2 | 3 |--- E1 E Comps 4 | |3|A|B|R| 5 | |6|A|B|R| 6 | |7|A|B|R| 7 | 8 '--- E2 E Comps 9 |4|A|B|R| 10 |5|A|B|R|When querying without specifying a target, the ‚Äúinner‚Äù archetypes are simply iterated if the node matches the filter. When querying with a relation target (and the node matches), the archetype for the target entity is looked up in a standard Go map.\nArchetype removal Normal archetypes without a relation are never removed, because they are not a temporary thing. For relation archetypes, however, things are different. Once a target entity dies, it will never appear again (actually it could, after dying another 4294967294 times).\nIn Arche, empty archetypes with a dead target are recycled. They are deactivated, but their allocated memory for entities and components is retained. When an archetype in the same node, but for another target entity is requested, it is reused. To be able to efficiently detect whether an archetype can be removed, a bitset is used to keep track of entities that are the target of a relation.\n",
    "description": "Arche's internal ECS architecture.",
    "tags": null,
    "title": "Architecture",
    "uri": "/background/architecture/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†User Guide",
    "content": "The World ( ecs.World ) is the central data storage in Arche. It manages and stores entities ( ecs.Entity ), their components, as well as Resources. For the internal structure of the world, see chapter Architecture.\nHere, we only deal with world creation. Most world functionality is covered in chapters Entities \u0026 Components and World Entity Access.\nWorld creation Reset the world World creation To create a world with default settings, use ecs.NewWorld :\n1world := ecs.NewWorld() 2_ = world A world can also be configured with a capacity increment, using an ecs.Config :\n1config := ecs.NewConfig().WithCapacityIncrement(1024) 2world := ecs.NewWorld(config) 3_ = world The capacity increment determines by how many entities an archetype grows when it reaches its capacity.\nFor archetypes with an Entity Relation, a separate capacity increment can be specified:\n1config := ecs.NewConfig(). 2\tWithCapacityIncrement(1024). 3\tWithRelationCapacityIncrement(128) 4 5world := ecs.NewWorld(config) 6_ = world Reset the world For systematic simulations, it is possible to reset a populated world for reuse:\n1world := ecs.NewWorld() 2// ... do something with the world 3 4world.Reset() 5// ... start over again ",
    "description": "The World as Arche's central data storage.",
    "tags": null,
    "title": "The World",
    "uri": "/guide/world/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†User Guide",
    "content": "Entities and components are the primary building blocks of the ECS concept. This chapter explains their representation and manipulation in Arche.\nEntities Components Component IDs Create entities Generic API Batch Creation Add and remove components Exchange components Remove entities Entities An Entity ( ecs.Entity ) in Arche is merely an ID and contains no data itself.\nThe only method of an entity is ecs.Entity.IsZero . The only entity that can be directly created by the user is the zero entity, in two possible ways:\n1var zero1 ecs.Entity 2fmt.Println(zero1.IsZero()) // prints true 3 4zero2 := ecs.Entity{} 5fmt.Println(zero2.IsZero()) // prints true All other entities must be created through the ecs.World (see section Creating entities below)\nComponents With each entity, an arbitrary number of Components can be associated. Components are simple, user-defined Go structs (or other go types):\n1// Position component 2type Position struct { 3 X float64 4 Y float64 5} 6 7// Heading component 8type Heading struct { 9 Angle float64 10}Components are stored in the World and accessed through Queries or through the world itself (see World Entity Access).\nComponent IDs Each component type has a unique ID, which is used to access it in the ID-based API. Component IDs can be registered as well as obtained through ecs.ComponentID .\n1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6_, _ = posID, headID When a type is used as a component the first time, it is automatically registered. Thus, it is not necessary to register all required components during initialization.\nCreate entities The most basic way to create an entity is ecs.World.NewEntity :\n1world := ecs.NewWorld() 2 3entity := world.NewEntity() 4_ = entity Here, we get an entity without any components. However, NewEntity takes an arbitrary number of components IDs for the components that should be associated with the entity:\n1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6_ = world.NewEntity(posID) 7_ = world.NewEntity(posID, headID) We get an entity with Position, and another one with Position and Heading. In this case, the components are initialized with their zero value. Alternatively, entities can be created with initialized components through ecs.World.NewEntityWith :\n1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6_ = world.NewEntityWith( 7\tecs.Component{ID: posID, Comp: \u0026Position{X: 1, Y: 2}}, 8\tecs.Component{ID: headID, Comp: \u0026Heading{Angle: 180}}, 9) We get an entity with Position and Heading, initialized according to the passed pointers.\nGeneric API Creating entities using the generic API requires a generic MapX, like generic.Map2 :\n1world := ecs.NewWorld() 2 3builder := generic.NewMap2[Position, Heading](\u0026world) 4 5_ = builder.New() We get an entity with Position and Heading, initialized to their zero values.\nEquivalent to ecs.World.NewEntityWith , generic MapX‚Äôs have NewWith :\n1world := ecs.NewWorld() 2 3builder := generic.NewMap2[Position, Heading](\u0026world) 4 5_ = builder.NewWith( 6\t\u0026Position{X: 1, Y: 2}, 7\t\u0026Heading{Angle: 180}, 8) Note The 2 in Map2 stands for the number of components. In the generic API, there are also FilterX and QueryX. All these types are available for X in range 0 (or 1) to 12.\nBatch Creation For faster batch creation of many entities, see chapter Batch Operations.\nAdd and remove components Components are added to and removed from entities through the world, with ecs.World.Add and ecs.World.Remove . With generics, use a generic.Map2 again:\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3mapper := generic.NewMap2[Position, Heading](\u0026world) 4 5entity := world.NewEntity() 6 7mapper.Add(entity) 8mapper.Remove(entity) 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6entity := world.NewEntity() 7 8world.Add(entity, posID, headID) 9world.Remove(entity, posID, headID) First, we add Position and Heading to the entity, then we remove both.\nImportant Note that generic types like MapX should be stored and re-used where possible, particularly over time steps.\nIt is also possible to assign initialized components with ecs.World.Assign / generic.Map2.Assign , similar to ecs.World.NewWith :\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3mapper := generic.NewMap2[Position, Heading](\u0026world) 4 5entity := world.NewEntity() 6 7mapper.Assign( 8\tentity, 9\t\u0026Position{X: 1, Y: 2}, 10\t\u0026Heading{Angle: 180}, 11) 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6entity := world.NewEntity() 7 8world.Assign( 9\tentity, 10\tecs.Component{ID: posID, Comp: \u0026Position{X: 1, Y: 2}}, 11\tecs.Component{ID: headID, Comp: \u0026Heading{Angle: 180}}, 12) Exchange components Sometimes one or more components should be added to an entity, and others should be removed. This can be bundled into a single exchange operation for efficiency. This is done with ecs.World.Exchange , or using a generic.Exchange :\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap1[Position](\u0026world) 4entity := builder.New() 5 6exchange := generic.NewExchange(\u0026world). 7\tAdds(generic.T[Heading]()). // Component(s) to add. 8\tRemoves(generic.T[Position]()) // Component(s) to remove. 9 10exchange.Exchange(entity) 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6entity := world.NewEntity(posID) 7 8world.Exchange(entity, 9\t[]ecs.ID{headID}, // Component(s) to add. 10\t[]ecs.ID{posID}, // Component(s) to remove. 11) Remove entities Entities can be removed from the world with ecs.World.RemoveEntity :\n1world := ecs.NewWorld() 2 3entity := world.NewEntity() 4world.RemoveEntity(entity) After removal, the entity will be recycled. For that sake, each entity has a generation variable which allows to distinguish recycled entities. With ecs.World.Alive , it can be tested whether an entity is still alive:\n1world := ecs.NewWorld() 2 3entity := world.NewEntity() 4fmt.Println(world.Alive(entity)) // prints true 5 6world.RemoveEntity(entity) 7fmt.Println(world.Alive(entity)) // prints false ",
    "description": "Entities, components, creation and removal in Arche.",
    "tags": null,
    "title": "Entities \u0026 Components",
    "uri": "/guide/entities/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†User Guide",
    "content": "Queries ( ecs.Query ) are the heart of Arche‚Äôs query engine. They allow for very fast retrieval and iteration of entities with certain components.\nImportant Queries are for one-time utilization. A query can be iterated through only once, and a new one must be created before every loop. Contrary, the underlying Filters should be stored and re-used.\nQuery creation \u0026 iteration World lock Other functionality Query.Count Query.EntityAt Query creation \u0026 iteration Queries are created through the ecs.World using a Filter (interface ecs.Filter ). The most basic type of filter is ecs.Mask . For more advanced filters, see chapter Filters.\nHere, we create a filter that gives us all entities with all the given components, and potentially further components. Then, we create an ecs.Query (or generic QueryX, e.g. generic.Query2 ) and iterate it.\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3filter := generic.NewFilter2[Position, Velocity]() 4query := filter.Query(\u0026world) 5for query.Next() { 6\tpos, vel := query.Get() 7\tpos.X += vel.X 8\tpos.Y += vel.Y 9} 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4velID := ecs.ComponentID[Velocity](\u0026world) 5 6filter := ecs.All(posID, velID) 7query := world.Query(filter) 8for query.Next() { 9\tpos := (*Position)(query.Get(posID)) 10\tvel := (*Velocity)(query.Get(velID)) 11\tpos.X += vel.X 12\tpos.Y += vel.Y 13} Where ecs.Query.Get (resp. generic.Query2.Get ) return components of the entity at the current query iterator position.\nComparing the two versions of the code above, one can clearly observe the advantages of the generic API over the ID-based API (see chapter on APIs). Firstly, the generic code is shorter and more readable. But even more importantly, it much safer. A little mistake in line 9 or 10 of the ID-based version could result in silently casting a component to the wrong type, which would lead to bugs that are hard to track down.\nTip If you get error messages like ‚Äúindex out of range [-1]‚Äù or ‚Äúinvalid memory address or nil pointer dereference‚Äù from queries, you are probably using them in the wrong way. Try running with build tag debug for more helpful error messages:\ngo run -tags debug . World lock When a query gets created, the ecs.World gets locked for modifications. When locked, no entities can be created or removed, and no components can be added to or removed from entities.\nWhen a query is fully iterated, the world gets unlocked again. When a query is not fully iterated for some reason (see next section for examples), it must be closed with ecs.Query.Close .\nDue to the world lock, denied operations like entity creation or removal must be deferred:\n1world := ecs.NewWorld() 2 3// Create some entities. 4for i := 0; i \u003c 100; i++ { 5\tworld.NewEntity() 6} 7 8// A slice that we (re)-use to defer entity removal. 9var toRemove []ecs.Entity 10 11// A time loop. 12for time := 0; time \u003c 100; time++ { 13\t// Query... the world gets locked. 14\tquery := world.Query(ecs.All()) 15\t// Iterate, and collect entities to remove. 16\tfor query.Next() { 17\tif rand.Float64() \u003c 0.1 { 18\ttoRemove = append(toRemove, query.Entity()) 19\t} 20\t} 21\t// The world is unlocked again. 22\t// Actually remove the collected entities. 23\tfor _, e := range toRemove { 24\tworld.RemoveEntity(e) 25\t} 26\t// Empty the slice, so we can reuse it in the next time step. 27\ttoRemove = toRemove[:0] 28} Where ecs.Query.Entity returns the entity at the current query iterator position.\nOther functionality Besides ecs.Query.Next , ecs.Query.Get and ecs.Query.Entity that we used above, queries have a few more useful methods.\nQuery.Count ecs.Query.Count allows for counting the entities in a query, very fast:\n1world := ecs.NewWorld() 2 3query := world.Query(ecs.All()) 4 5cnt := query.Count() 6fmt.Println(cnt) 7 8query.Close() Note that we need to call ecs.Query.Close here, as the query was not (fully) iterated! After ecs.Query.Count , the query could also be iterated as usual.\nQuery.EntityAt With ecs.Query.EntityAt , queries also support access by index. This is particularly useful to select random entities from a query, like in this example:\n1world := ecs.NewWorld() 2 3// Create some entities. 4for i := 0; i \u003c 100; i++ { 5\tworld.NewEntity() 6} 7 8// Query and count entities. 9query := world.Query(ecs.All()) 10cnt := query.Count() 11 12// Draw random entities. 13for i := 0; i \u003c 10; i++ { 14\tentity := query.EntityAt(rand.Intn(cnt)) 15\tfmt.Println(entity) 16} 17 18query.Close() Note that we need to close the query manually, again! To access components of the retrieved entities, see chapter World Entity Access.\nNote that ecs.Query.EntityAt may be slow when working with a large number of archetypes. Often, it is useful to register the underlying filter for speedup. See chapter Filter, section Filter caching for details. See the query benchmarks for some numbers on performance.\n",
    "description": "Usage of Arche's queries.",
    "tags": null,
    "title": "Queries",
    "uri": "/guide/queries/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†Background",
    "content": "This chapter gives an overview of the runtime cost of typical Arche operations. All time information is per entity. Batch operations are performed in batches of 1000 entities.\nAbsolute numbers are not really meaningful, as they heavily depend on the hardware. However, all benchmarks run in the CI in the same job and hence on the same machine, and can be compared.\nBenchmark code: benchmark/table in the GitHub repository.\nBenchmarks are run automatically in the GitHub CI, and are updated on this page on every merge into the main branch. They always reflect the latest development state of Arche, but may change depending on the hardware the CI runs on. For a benchmark comparison with other ECS implementations, see the benchmarks on the repo README.\nQuery World access Entities Entities, batched Components Components, batched Last run: Mon, 08 Jul 2024 19:39:20 UTC\nQuery Operation Time Remark Query.Next 1.0 ns Query.Next + 1x Query.Get 1.6 ns Query.Next + 2x Query.Get 2.0 ns Query.Next + 5x Query.Get 4.4 ns Query.Next + Query.Entity 1.3 ns Query.Next + Query.Relation 2.2 ns Query.EntityAt, 1 arch 11.9 ns Query.EntityAt, 1 arch 2.8 ns registered filter Query.EntityAt, 5 arch 31.8 ns Query.EntityAt, 5 arch 5.0 ns registered filter World.Query 46.1 ns World.Query 34.5 ns registered filter World access Operation Time Remark World.Get 2.1 ns random, 1000 entities World.GetUnchecked 1.5 ns random, 1000 entities World.Has 1.3 ns random, 1000 entities World.HasUnchecked 0.7 ns random, 1000 entities World.Alive 0.6 ns random, 1000 entities World.Relations.Get 3.5 ns random, 1000 entities World.Relations.GetUnchecked 0.8 ns random, 1000 entities Entities Operation Time Remark Entity.IsZero 0.2 ns World.NewEntity 16.5 ns memory already allocated World.NewEntity w/ 1 Comp 35.2 ns memory already allocated World.NewEntity w/ 5 Comps 47.0 ns memory already allocated World.RemoveEntity 14.6 ns World.RemoveEntity w/ 1 Comp 26.3 ns World.RemoveEntity w/ 5 Comps 54.2 ns Entities, batched Operation Time Remark Builder.NewBatch 10.2 ns 1000, memory already allocated Builder.NewBatch w/ 1 Comp 10.4 ns 1000, memory already allocated Builder.NewBatch w/ 5 Comps 10.6 ns 1000, memory already allocated Batch.RemoveEntities 7.2 ns 1000 Batch.RemoveEntities w/ 1 Comp 7.6 ns 1000 Batch.RemoveEntities w/ 5 Comps 7.7 ns 1000 Components Operation Time Remark World.Add 1 Comp 48.5 ns memory already allocated World.Add 5 Comps 63.7 ns memory already allocated World.Remove 1 Comp 62.7 ns World.Remove 5 Comps 102.2 ns World.Exchange 1 Comp 56.5 ns memory already allocated Components, batched Operation Time Remark Batch.Add 1 Comp 8.8 ns 1000, memory already allocated Batch.Add 5 Comps 8.5 ns 1000, memory already allocated Batch.Remove 1 Comp 9.8 ns 1000 Batch.Remove 5 Comps 14.8 ns 1000 Batch.Exchange 1 Comp 10.5 ns 1000, memory already allocated ",
    "description": "An overview of the runtime cost of typical Arche operations.",
    "tags": null,
    "title": "Benchmarks",
    "uri": "/background/benchmarks/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†User Guide",
    "content": "Filters provide the logic for filtering entities in Queries.\nDue to the archetype-based architecture of Arche üòâ, filters are very efficient. Instead of against every single entity, they are only matched against archetypes.\nThe following sections present the filtering options available in Arche.\nImportant Filters should be stored and re-used where possible, particularly over time steps. Contrary, Queries are for one-time utilization and must be created from a filter before every iteration loop.\nCore filters Mask Without Exclusive With \u0026 Optional Relation filters Logic filters Filter caching Core filters Mask The most common filter is a simple ecs.Mask , which is usually generated with the function ecs.All :\n1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6mask := ecs.All(posID, headID) 7 8query := world.Query(mask) 9query.Close() Simple ecs.Mask filters match all entities that have at least all the specified components. The generic equivalent is a simple FilterX, e.g. generic.Filter2 :\n1world := ecs.NewWorld() 2 3filter := generic.NewFilter2[Position, Heading]() 4query := filter.Query(\u0026world) 5query.Close() In both examples, we filter for all entities that have Position and Heading, and anything else that we are not interested in.\nWithout Particular components can be excluded with ecs.Mask.Without and generic.Filter2.Without :\n‚Äã generic ID-based 1filter := generic.NewFilter1[Position](). 2\tWithout(generic.T[Heading]()) 3 4_ = filter 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6mask := ecs.All(posID).Without(headID) 7_ = mask Here, we filter for all entities that have a Position, but no Heading. Other components are allowed on the entities.\nExclusive With ecs.Mask.Exclusive and generic.Filter2.Exclusive , we can exclude all components that are not in the filter:\n‚Äã generic ID-based 1filter := generic.NewFilter2[Position, Heading](). 2\tExclusive() 3_ = filter 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6mask := ecs.All(posID, headID).Exclusive() 7_ = mask I.e., we get only entities with exactly the given components, and no more.\nWith \u0026 Optional With the ID-based API, queries allow access to any component, irrespective of whether it was included in the query. Generic queries, however, can access only the queried components. Therefore, generic filters can have optional components through generic.Filter2.Optional :\n1world := ecs.NewWorld() 2 3filter := generic.NewFilter2[Position, Heading](). 4\tOptional(generic.T[Heading]()) 5 6query := filter.Query(\u0026world) 7for query.Next() { 8\t_, head := query.Get() 9\tif head == nil { 10\t// Optional component Heading not present 11\tfmt.Println(\"Heading not present in entity \", query.Entity()) 12\t} 13} Note that the now optional Heading must be specified also in the original filter. In case an optional component is not present, Get returns nil for it.\nFurther, generic filters have generic.Filter2.With . This requires the respective component(s) to be present, but they are not obtained through Get:\n1world := ecs.NewWorld() 2 3filter := generic.NewFilter1[Position](). 4\tWith(generic.T[Heading]()) 5 6query := filter.Query(\u0026world) 7for query.Next() { 8\tpos := query.Get() 9\t_ = pos 10} Relation filters Filters for Entity Relations are covered in the respective chapter.\nLogic filters Package filter provides logic combinations of filters. Logic filters can only be used with the ID-based API. Here are some examples:\n1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4velID := ecs.ComponentID[Velocity](\u0026world) 5headID := ecs.ComponentID[Heading](\u0026world) 6 7// Either Position and Velocity, or Position and Heading. 8_ = filter.OR{ 9\tL: ecs.All(posID, velID), 10\tR: ecs.All(posID, headID), 11} 12 13// Same as above, expressed with a different logic. 14_ = filter.AND{ 15\tL: ecs.All(posID), 16\tR: filter.Any(velID, headID), 17} 18 19// Missing any of Position or Velocity. 20_ = filter.AnyNot(posID, velID) Filter caching Normally, when iterating a Query, the underlying filter is evaluated on each archetype. With a high number of archetypes in the world, this can slow down query iteration and other query functions.\nTo prevent this slowdown, filters can be registered to the ecs.World.Cache via ecs.Cache.Register . For generic filters, there is generic.Filter2.Register :\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3filter := generic.NewFilter1[Position]() 4filter.Register(\u0026world) 5 6query := filter.Query(\u0026world) 7query.Close() 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4 5mask := ecs.All(posID) 6filter := world.Cache().Register(mask) 7 8// Use the registered filter in queries! 9query := world.Query(\u0026filter) 10query.Close() For registered filters, the list of matching archetypes is cached internally. Thus, no filter evaluations are required during iteration. Instead, filters are only evaluated when a new archetype is created.\nWhen a registered filter is not required anymore, it can be unregistered with ecs.Cache.Unregister or generic.Filter2.Unregister , respectively. However, this is rarely required as (registered) filters are usually used over an entire simulation run.\n",
    "description": "Arche's filter APIs.",
    "tags": null,
    "title": "Filters",
    "uri": "/guide/filters/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†User Guide",
    "content": "So far, we only used ecs.Query to access components. Component access in queries is highly efficient, but it does not provide access to the components of a specific entity. This is possible through ecs.World methods, or using a generic MapX (like generic.Map2 ) or generic.Map .\nGetting components Unchecked access Getting components For a given entity, components can be accessed using ecs.World.Get or generic.Map2.Get , respectively:\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap2[Position, Heading](\u0026world) 4entity := builder.New() 5 6pos, head := builder.Get(entity) 7 8_, _ = pos, head 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6entity := world.NewEntity(posID, headID) 7 8pos := (*Position)(world.Get(entity, posID)) 9head := (*Heading)(world.Get(entity, headID)) 10 11_, _ = pos, head Similarly, it is also possible to check if an entity has a given component with ecs.World.Has or generic.Map.Has , respectively:\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap2[Position, Heading](\u0026world) 4entity := builder.New() 5 6mapper := generic.NewMap[Position](\u0026world) 7 8hasPos := mapper.Has(entity) 9_ = hasPos 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6entity := world.NewEntity(posID, headID) 7 8hasPos := world.Has(entity, posID) 9_ = hasPos Note that we have to use generic.Map here, which is similar to generic.Map1 for a single component, but offers more functionality.\nUnchecked access The Get and Has methods shown above all have a companion GetUnchecked and HasUnchecked, which is faster, but should be used with care. Particularly, they do not check whether the entity is still alive. Like Get, they panic when called on a removed entity. However, for a removed and subsequently recycled entity, they lead to undefined behavior.\nIt is safe to use methods like ecs.World.GetUnchecked after a usual Get was used on the same entity:\n1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6entity := world.NewEntity(posID, headID) 7 8pos := (*Position)(world.Get(entity, posID)) 9head := (*Heading)(world.GetUnchecked(entity, headID)) 10 11_, _ = pos, head Note that, following this use case, generic MapX internally use ecs.World.GetUnchecked for all but the first component.\n",
    "description": "Access to components through the world, by entity ID.",
    "tags": null,
    "title": "World Entity Access",
    "uri": "/guide/world-access/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†User Guide",
    "content": "In a basic ECS, relations between entities, like hierarchies, can be represented by storing entities in components. E.g., we could have a child component like this:\n1type ChildOf struct { 2 Parent ecs.Entity 3}Or, alternatively, a parent component with many children:\n1type Parent struct { 2 Children []ecs.Entity 3}In conjunction with World Entity Access, this is often sufficient. However, we are not able to leverage the power of queries to e.g. get all children of a particular parent.\nTo make entity relations even more useful and efficient, Arche supports them as first class feature. Relations are added to and removed from entities just like components, and hence can be queried like components, with the usual efficiency. This is achieved by creating separate archetypes for relations with different target entities.\nRelation components Creating relations On new entities When adding components Set and get relations Querying relations Limitations When to use, and when not Benchmarks Longer example Relation components To use entity relations, create components that have embedded an ecs.Relation as their first member:\n1type ChildOf struct { 2 ecs.Relation 3}That‚Äôs all to make a component be treated as an entity relation by Arche. Thus, we have created a relation type. When added to an entity, a target entity for the relation can be defined.\nNote Note that each entity can only have one relation component. See section Limitations.\nCreating relations On new entities When creating entities, we can use an ecs.Builder to set a relation target. In the generic API, we use a MapX (e.g. generic.Map2 ).\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3// The second argument specifies the relation component. 4builder := generic.NewMap2[Position, ChildOf](\u0026world, generic.T[ChildOf]()) 5 6_ = builder.New() // An entity with a zero target. 7 8parent := world.NewEntity() 9_ = builder.New(parent) // An entity with parent as target. 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4childID := ecs.ComponentID[ChildOf](\u0026world) 5 6// We set the relation component with WithRelation. 7builder := ecs.NewBuilder(\u0026world, posID, childID).WithRelation(childID) 8 9_ = builder.New() // An entity with a zero target. 10 11parent := world.NewEntity() 12_ = builder.New(parent) // An entity with parent as target. When adding components A relation target can also be given when adding a relation component. With the ID-based API, we use the helper ecs.World.Relations for this, like for most operations on entity relations. In the generic API, we use a MapX (e.g. generic.Map2 ) again.\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap1[Position](\u0026world) 4adder := generic.NewMap1[ChildOf](\u0026world, generic.T[ChildOf]()) 5 6parent := world.NewEntity() 7child := builder.New() 8 9adder.Add(child, parent) 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4childID := ecs.ComponentID[ChildOf](\u0026world) 5 6parent := world.NewEntity() 7child := world.NewEntity(posID) 8 9world.Relations().Exchange( 10\tchild, // The entity to modify 11\t[]ecs.ID{childID}, // Component(s) to add 12\tnil, // Component(s) to remove 13\tchildID, // The relation component of the added components 14\tparent, // The target entity 15) Alternatively, we can use a generic.Exchange :\n1world := ecs.NewWorld() 2 3builder := generic.NewMap1[Position](\u0026world) 4adder := generic.NewExchange(\u0026world). 5\tAdds(generic.T[ChildOf]()). // Component(s) to add 6\tWithRelation(generic.T[ChildOf]()) // The relation component of the added components 7 8parent := world.NewEntity() 9child := builder.New() 10 11adder.Add(child, parent) Set and get relations We can also change the target of an already assigned relation component. This is done via ecs.Relations.Set or generic.Map.SetRelation :\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap1[ChildOf](\u0026world) 4mapper := generic.NewMap[ChildOf](\u0026world) 5 6parent := world.NewEntity() 7child := builder.New() 8 9mapper.SetRelation(child, parent) 1world := ecs.NewWorld() 2 3childID := ecs.ComponentID[ChildOf](\u0026world) 4 5parent := world.NewEntity() 6child := world.NewEntity(childID) 7 8world.Relations().Set(child, childID, parent) Similarly, relation targets can be obtained with ecs.Relations.Get or generic.Map.GetRelation :\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap1[ChildOf](\u0026world) 4mapper := generic.NewMap[ChildOf](\u0026world) 5 6child := builder.New() 7 8_ = mapper.GetRelation(child) 1world := ecs.NewWorld() 2childID := ecs.ComponentID[ChildOf](\u0026world) 3 4child := world.NewEntity(childID) 5 6_ = world.Relations().Get(child, childID) Querying relations And now for the best: querying for entities that have a certain relation and target.\nIn the ID-based API, relation targets can be queries with ecs.RelationFilter . In the generic API, it is supported by all FilterX via e.g. generic.Filter2.WithRelation .\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3// Two parent entities. 4parent1 := world.NewEntity() 5parent2 := world.NewEntity() 6 7// A builder with a relation 8builder := generic.NewMap2[Position, ChildOf](\u0026world, generic.T[ChildOf]()) 9 10// Create 10 entities for each parent. 11for i := 0; i \u003c 10; i++ { 12\tbuilder.New(parent1) 13\tbuilder.New(parent2) 14} 15 16// A filter for all entities with Position, 17// and a ChildOf relation. 18filter := generic.NewFilter2[Position, ChildOf](). 19\tWithRelation(generic.T[ChildOf]()) 20 21// We specify the target when querying. 22// Alternatively, a fixed target can be specified in WithRelation above. 23query := filter.Query(\u0026world, parent1) 24fmt.Println(query.Count()) // Prints 10 25 26query.Close() 1world := ecs.NewWorld() 2posID := ecs.ComponentID[Position](\u0026world) 3childID := ecs.ComponentID[ChildOf](\u0026world) 4 5// Two parent entities. 6parent1 := world.NewEntity() 7parent2 := world.NewEntity() 8 9// A builder with a relation 10builder := ecs.NewBuilder(\u0026world, posID, childID). 11\tWithRelation(childID) 12 13// Create 10 entities for each parent. 14for i := 0; i \u003c 10; i++ { 15\tbuilder.New(parent1) 16\tbuilder.New(parent2) 17} 18 19// A filter for all entities with Position, 20// and ChildOf with target parent1. 21filter := ecs.NewRelationFilter(ecs.All(posID, childID), parent1) 22 23query := world.Query(\u0026filter) 24fmt.Println(query.Count()) // Prints 10 25 26query.Close() Limitations Entity relations in Arche are inspired by Flecs. However, the implementation in Arche is currently limited in that it only supports a single relation per entity, and no chained (or nested) relation queries.\nWhen to use, and when not When using Arche‚Äôs entity relations, an archetype is created for each target entity of a relation. Thus, entity relations are not efficient if the number of target entities is high (tens of thousands), while only a low number of entities has a relation to each particular target (less than a few dozens). Particularly in the extreme case of 1:1 relations, storing entities in components as explained in the introduction of this chapter is more efficient.\nHowever, with a moderate number of relation targets, particularly with many entities per target, entity relations are very efficient. See section Benchmarks below, for a comparison of different ways to represent entity relations.\nBeyond use cases where the relation target is a ‚Äúphysical‚Äù entity that appears in a simulation or game, targets can also be more abstract, like categories. Examples:\nDifferent tree species in a forest model Behavioral states in a finite state machine The opposing factions in a strategy game Render layers in a game or other graphical application This concept is particularly useful for things that would best be expressed by components, but the possible components (or categories) are only known at runtime. Thus, it is not possible to create ordinary components for them. However, these categories can be represented by entities, which are used as relation targets.\nSee the last section of this chapter (Longer example) for an implementation of the tree species example above.\nBenchmarks The figure below compares the iteration time per entity for different ways of representing entity relations. The task is to sum up a value over the children of each parent.\nThe following ways to represent entity relations are shown in the figure:\nParentList (purple): Children form an implicit linked list. The parent references the first child. Query over parents, inner loop implicit linked list of children, using world access for next child and value component. ParentSlice (red): The parent holds a slice of all its children. Query over parents, inner loop over slice of children using world access for value component. Child (green): Each child references its parent. Query over all child entities and retrieval of the parent sum component using world access. Default (blue): Using Arche‚Äôs relations feature without filter caching. Outer query over parents, inner loop over children using relation queries. Cached (black): Using Arche‚Äôs relations feature with filter caching. Same as above, using an additional component per parent to store cached filters. The first three representations are possible in any ECS, while the last two use Arche‚Äôs entity relations feature.\nIteration time per entity for different ways of representing entity relations. Color: ways to represent entity relations; Line style: total number of child entities; Markers: number of children per parent entity\nThe benchmarks show that Arche‚Äôs relations feature outperforms the other representations, except when there are very few children per parent. Only when there is a huge number of parents and significantly fewer than 100 children per parent, the Child representation should perform better.\nThe benchmark code can be found in the GitHub repository.\nLonger example To conclude this chapter, here is a longer example that uses Arche‚Äô entity relations feature to represent tree species in a forest model.\n1package main 2 3import ( 4\t\"math/rand\" 5 6\t\"github.com/mlange-42/arche/ecs\" 7\t\"github.com/mlange-42/arche/generic\" 8) 9 10// SpeciesParams component for species (relation targets). 11type SpeciesParams struct { 12\tGrowthRate float64 13} 14 15// Species relation component for tree individuals. 16type Species struct { 17\tecs.Relation 18} 19 20// Biomass component for tree individuals. 21type Biomass struct { 22\tBM float64 23} 24 25func main() { 26\tworld := ecs.NewWorld() 27 28\tspeciesBuilder := generic.NewMap1[SpeciesParams](\u0026world) 29\ttreeBuilder := generic.NewMap2[Biomass, Species](\u0026world, generic.T[Species]()) 30 31\t// Create 10 species. 32\tfor s := 0; s \u003c 10; s++ { 33\tspecies := speciesBuilder.NewWith( 34\t\u0026SpeciesParams{GrowthRate: rand.Float64()}, 35\t) 36 37\t// Create 100 trees per species. Biomass is zero. 38\tfor t := 0; t \u003c 100; t++ { 39\ttreeBuilder.New(species) 40\t} 41\t} 42 43\tspeciesFilter := generic.NewFilter1[SpeciesParams]() 44\ttreeFilter := generic.NewFilter1[Biomass](). // We want to access biomass. 45\tWith(generic.T[Species]()). // We want this, but will not access it 46\tWithRelation(generic.T[Species]()) // Finally, the relation. 47 48\t// Time loop. 49\tfor tick := 0; tick \u003c 100; tick++ { 50\t// Query and iterate species. 51\tspeciesQuery := speciesFilter.Query(\u0026world) 52\tfor speciesQuery.Next() { 53\t// Get species params and entity. 54\tparams := speciesQuery.Get() 55\tspecies := speciesQuery.Entity() 56 57\t// Query and iterate trees for the current species. 58\ttreeQuery := treeFilter.Query(\u0026world, species) 59\tfor treeQuery.Next() { 60\tbm := treeQuery.Get() 61\t// Increase biomass by the species' growth rate. 62\tbm.BM += params.GrowthRate 63\t} 64\t} 65\t} 66 67\t_ = world 68} ",
    "description": "Arche's entity relationships feature.",
    "tags": null,
    "title": "Entity Relations",
    "uri": "/guide/relations/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†User Guide",
    "content": "Compared to Queries and World Entity Access, creation and removal of entities or components are relatively costly operations. See the Benchmarks for some numbers.\nFor these operations, Arche provides batched versions. This allows to create or manipulate a large number of entities much faster than one by one. Most batch methods come in two flavors. A ‚Äúnormal‚Äù one, and one suffixed with Q that returns a query over the affected entities.\nCreating entities Components Relations Removing entities Creating entities Entity creation is probably the most common use case for batching. When the number of similar entities that are to be created are known, creation can be batched with ecs.Builder.NewBatch . In the generic API, MapX provide e.g. generic.Map2.NewBatch .\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap2[Position, Heading](\u0026world) 4 5builder.NewBatch(100) 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6builder := ecs.NewBuilder(\u0026world, posID, headID) 7 8builder.NewBatch(100) However, this is only sometimes useful, as we can‚Äôt initialize component fields here.\nWith the query variant of the methods, suffixed with Q, we can fix this:\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3builder := generic.NewMap2[Position, Heading](\u0026world) 4 5query := builder.NewBatchQ(100) 6for query.Next() { 7\tpos, head := query.Get() 8 9\tpos.X = rand.Float64() * 100 10\tpos.Y = rand.Float64() * 100 11\thead.Angle = rand.Float64() * 360 12} 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6builder := ecs.NewBuilder(\u0026world, posID, headID) 7 8query := builder.NewBatchQ(100) 9for query.Next() { 10\tpos := (*Position)(query.Get(posID)) 11\thead := (*Heading)(query.Get(headID)) 12 13\tpos.X = rand.Float64() * 100 14\tpos.Y = rand.Float64() * 100 15\thead.Angle = rand.Float64() * 360 16} Here, we obtain a query over exactly the entities we just created, and can initialize their components.\nComponents Components can be added, removed or exchanged in batch operations. For these operations, Arche provides ecs.World.Batch . Component batch operations take an ecs.Filter as an argument to determine the affected entities.\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3// Create 100 entities with Position. 4builder := generic.NewMap1[Position](\u0026world) 5builder.NewBatch(100) 6 7// Create a generic map to perform the batch operation 8adder := generic.NewMap1[Heading](\u0026world) 9// Filter for entities with Position. 10filter := generic.NewFilter1[Position]() 11// Batch-add Heading to them, using the query method for initialization. 12query := adder.AddBatchQ(filter.Filter(\u0026world)) 13for query.Next() { 14\thead := query.Get() 15\thead.Angle = rand.Float64() * 360 16} 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4headID := ecs.ComponentID[Heading](\u0026world) 5 6// Create 100 entities with Position. 7builder := ecs.NewBuilder(\u0026world, posID) 8builder.NewBatch(100) 9 10// Filter for entities with Position. 11filter := ecs.All(posID) 12// Batch-add Heading to them, using the query method for initialization. 13query := world.Batch().AddQ(filter, headID) 14for query.Next() { 15\thead := (*Heading)(query.Get(headID)) 16\thead.Angle = rand.Float64() * 360 17} Methods of interest for the ID-based API are:\necs.Batch.Add , ecs.Batch.AddQ ecs.Batch.Remove , ecs.Batch.RemoveQ ecs.Batch.Exchange , ecs.Batch.ExchangeQ Methods of interest for the generic API are:\ngeneric.Map2.AddBatch , generic.Map2.AddBatchQ generic.Map2.RemoveBatch , generic.Map2.RemoveBatchQ generic.Exchange.ExchangeBatch Relations Entity relations can be changed in batches, too. In the ID-based API, both ecs.Batch.SetRelation / ecs.Batch.SetRelationQ and ecs.Relations.SetBatch / ecs.Relations.SetBatchQ can be used. In the generic API, use generic.Map.SetRelation / generic.Map.SetRelationQ :\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3childID := ecs.ComponentID[ChildOf](\u0026world) 4 5parent := world.NewEntity() 6 7// Create 100 entities with ChildOf relation. 8builder := generic.NewMap1[ChildOf](\u0026world) 9builder.NewBatch(100) 10 11// Create a generic map to perform the batch operation 12mapper := generic.NewMap[ChildOf](\u0026world) 13// Filter for entities with ChildOf. 14filter := ecs.All(childID) 15// Batch-set their relation target to parent. 16mapper.SetRelationBatch(filter, parent) 1world := ecs.NewWorld() 2 3childID := ecs.ComponentID[ChildOf](\u0026world) 4 5parent := world.NewEntity() 6 7// Create 100 entities with ChildOf relation. 8builder := ecs.NewBuilder(\u0026world, childID) 9builder.NewBatch(100) 10 11// Filter for entities with ChildOf. 12filter := ecs.All(childID) 13// Batch-set their relation target to parent. 14world.Batch().SetRelation(filter, childID, parent) Removing entities Entities can be removed in batches using ecs.Batch.RemoveEntities :\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3// Create 100 entities with Position. 4builder := generic.NewMap1[Position](\u0026world) 5builder.NewBatch(100) 6 7// Filter for entities with Position. 8filter := generic.NewFilter1[Position]() 9// Batch-remove matching entities. 10world.Batch().RemoveEntities(filter.Filter(\u0026world)) 1world := ecs.NewWorld() 2 3posID := ecs.ComponentID[Position](\u0026world) 4 5// Create 100 entities with Position. 6builder := ecs.NewBuilder(\u0026world, posID) 7builder.NewBatch(100) 8 9// Filter for entities with Position. 10filter := ecs.All(posID) 11// Batch-remove matching entities. 12world.Batch().RemoveEntities(filter) ",
    "description": "Batch operations in Arche.",
    "tags": null,
    "title": "Batch Operations",
    "uri": "/guide/batch-ops/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†Background",
    "content": "[v0.13.0] Features Adds function ResourceTypeID to register/get a resource ID from a reflect.Type (#420) Other Fix component type in examples/base (#419) [v0.12.0] Features Adds Entity.ID() and Entity.Generation() (#408, delaneyj) Documentation Adds a showcase chapter ‚ÄúMade with Arche‚Äù to the documentation page (#411) Performance Re-arrange struct fields to save memory in a few places (#413) Bugfixes Fix crash caused by extending layouts of an inactive archetype (#416, reported in #415) First-time contributors delaneyj [v0.11.0] Highlights Arche now has a dedicated documentation site with a structured user guide and background information. We hope that this will lower the barrier to entrance significantly.\nFurther, Arche got a few new features:\nQuery.EntityAt was added for random access to query entities. Generic filters now support Exclusive, like ID-based filters. Build tag debug improves error messages in a few places where we rely on standard library panics for performance. Breaking changes Renames types in ecs.stats to follow Go standards. stats.WorldStats -\u003e stats.World, stats.NodeStats -\u003e stats.Node, ‚Ä¶ (#388) Features Adds method Query.EntityAt(), useful for things like random sampling of entities (#358) Adds build tag debug to improve error messages in a few places where we rely on standard library panics for performance (#377) Adds method FilterX.Exclusive() to all generic filters (#381) Documentation Adds a dedicated Arche User Guide web site (#380, #382, #383, #384, #385) Adds BENCHMARKS.md benchmarks for a tabular overview of the runtime cost of typical Arche ECS operations (#367, #372) Link benchmarking code in README.md and benchmarking tables (#375) Documents build tags tiny and debug in package docs of ecs (#377) Adds examples to demonstrate the use of non-ECS data structures together with ECS (#379) Bugfixes Prevents using the same component multiple times in any operations, through panic (#357) Performance Generic filters use Mask instead of slower MaskFilter if no components are excluded (#381) Other Improves error messages for running out of world locks, components or resources, and on unbalanced unlock (#363) Adds benchmarks for query creation (#366) Upgrade to Go 1.22 in CI (#376) Renames directory examples to _examples to accommodate changed test coverage behaviour of Go 1.22 (#376) In unit tests, error messages of all panics are asserted (#377) [v0.10.1] Bugfixes Fix IsRelation check to allow for non-struct components, like type aliases (#354) Other Repository arche-demo provides a live demo of several models built with Arche. [v0.10.0] Highlights Arche supports full world serialization and deserialization, in conjunction with arche-serde (#319) Supports 256 instead of 128 component types as well as resource types and engine locks (#313) Generic API supports up to 12 instead of 8 component types (#324) Reworked event system with granular subscription to different event types and components (#333, #334, #335, #337, #340) Breaking changes MaskTotalBits changed from 128 to 256 (#313) Removes Mask.Lo and Mask.Hi, internal mask representation is now private (#313) Filter.Matches(Mask) became Filter.Matches(*Mask); same for all Filter implementations (#313)\nThis change was necessary to get the same performance as before, despite the more heavyweight implementation of the now 256 bits Mask. Component and resource IDs are now opaque types instead of type aliases for uint8 (#330) Restructures EntityEvent to remove redundant information and better handle relation changes (#333) World event listener changed from a simple function to a Listener interface (#334) Removes World.ComponentType(ID), use function ComponentInfo(ID) instead (#341) Features Adds functions ComponentInfo(*World, ID) and ResourceType(*World, ResID) (#315, #318) Adds methods World.Ids(Entity) and Query.Ids() to get component IDs for an entity (#315, #325) Entities support JSON marshalling and unmarshalling (#319) The world‚Äôs entity state can be extracted and re-established via World.DumpEntities() and World.LoadEntities() (#319, #326) Adds functions ComponentIDs(*World) and ResourceIDs(*World) to get all registered IDs (#330) Adds methods Mask.And, Mask.Or and Mask.Xor (#335) Adds build tag tiny to restrict to 64 components for an extra bit of performance (#338) Adds methods Relations.Exchange(), Relations.ExchangeBatch(), Relations.ExchangeBatchQ() for exchange with relation target (#342) Generic API adds Exchange.WithRelation() and optional target argument for operations with relation target (#342) Generic API adds MapX.AddBatch(), MapX.AddBatchQ(), MapX.RemoveBatch()and MapX.RemoveBatchQ() (#342) Generic API adds optional relation target argument to most MapX methods (#342) Generic API adds FilterX.Filter() to get an ecs.Filter from a generic one (#342) Generic API adds Map.SetRelationBatch() and Map.SetRelationBatchQ() (#344) All batch operations (except entity creation) return the number of affected entities (#348) Performance Reduces archetype memory footprint by using a dynamically sized slice for storage lookup (#327) Reduces event listener overhead through granular subscriptions and elimination of a heap allocation (#333, #334, #335, #337, #340) Documentation Adds an overview to packages ecs and generic on how to achieve ECS manipulation operations (#345) Other Entity generation data type changed from uint16 to uint32 (#317) Adds unitoftime/ecs to competition benchmarks (#311) Adds competition benchmarks for accessing 10 components (#328) [v0.9.0] Infrastructure Upgraded to Go 1.21 toolchain (#308) [v0.8.1] Documentation Emphasize in Entity and World docs that entities are intended to be stored and passed by copy, not by pointer (#306) [v0.8.0] Highlights Entity relations were added as a first-class feature (#231, #271)\nRelations are used to represent graphs of entities, e.g. hierarchies. They can be added, removed and queried just like normal components. The new feature offers ergonomic handling of entity relations, and provides relation queries with native performance.\nBreaking changes Removed World.Batch for entity batch creation, use Builder instead (#239) Rework of generic entity creation API, use MapX.New, MapX.NewWith, MapX.NewBatch and MapX.NewQuery (#239, #252) Stats object WorldStats etc. adapted for new structure of archetypes nested in nodes (#258) Removed generic filter method FilterX.Filter (#271) Method Batch.NewQuery renamed to Batch.NewBatchQ (#298) Features Relation archetypes are removed when they are empty and the target entity is dead (#238, #242) Support an unlimited number of cached filters, instead of 128 (#245) WorldStats contains the number of cached filters (#247) Archetypes with entity relations are removed on World.Reset (#247) Capacity increment can be configured separately for relation archetypes (#257) Adds methods for faster, unchecked entity relation access (#259) Re-introduce World.Batch for batch-processing of entities (add/remove/exchange) (#264) New method Builder.Add for adding components with a target to entities (#264) New method Batch.SetRelation for batch-setting entity relations (#265) New methods Builder.AddQ, Builder.RemoveQ etc. to get a query over batch-processed entities (#297) Sends an EntityEvent to the world listener on relation target changes (#265) Performance Reduce memory footprint of archetypes by moving properties to nodes (#237) Queries iterate archetype graph nodes in an outer loop, potentially skipping nested relation archetypes (#248) Relation archetypes are recycled in archetype graph nodes (#248) Already empty archetypes are not zeroed on reset (#248) Optimize RelationFilter: get archetype directly instead of iterating complete node (#251) Cached filters use swap-remove when removing an archetype (#253) Speed up generic query re-compilation after changing the relation target (#255) Speed up archetype and node iteration to be as fast as before the new nested structure (#270, #288) Filter cache stores archetype graph nodes instead of archetypes (#276) (#288) Use uint32 instead of uintptr for indices and query iteration counter (#283) Cached filters use a map for faster removal of archetypes (#289) Speed up iterating through many archetypes by approx. 10% (#301) Documentation Adds an example for creating and querying entity relations (#256) Adds a section on entity relations to the ARCHITECTURE.md document (#256) Replace Aos benchmarks plot in README for pointer iteration fix #284 (#285) Adds a plot for entity relation benchmarks to ARCHITECTURE.md (#290) Adds an outline of the most important types and functions to each sub-package (#295) Other Remove go-gameengine-ecs from Arche benchmarks (but not from competition!) (#228) Reduce memory size of Query and internal archetype list by 8 bytes (#230) Generic filters are locked when registered for caching (#241) Adds benchmarks for getting and setting entity relations (#259) Arche now has an official logo (#273) Use for loop with counter in AoS competition benchmarks, to allow for pointers (#284) [v0.7.1] Documentation Tweak/improve example batch_ops (#222) Adds an example for running simulations in parallel (#223) Other Adds benchmarks for world component access with shuffled entities (#224) [v0.7.0] Features Adds method World.ComponentType(ID) to get the reflect.Type for component IDs (#215) Adds methods World.GetUnchecked and World.HasUnchecked as optimized variants for known static entities (#217, #219) Adds method MapX.GetUnchecked to all generic mappers, as equivalent to previous point (#217, #219) Adds methods Map.GetUnchecked and Map.HasUnchecked to generic Map, as equivalent to previous points (#217, #219) Performance Optimize World.Alive(Entity) by only checking the entity generation, but not id == 0 (#220) Bugfixes All world methods with an entity as argument panic on a dead/recycled entity; causes 0.5ns slower World.Get(Entity) (#216) [v0.6.3] Documentation Minor README and docstring tweaks (#211, #213) Other Use coveralls.io for test coverage, add respective badge (#212) [v0.6.2] Performance Speed up generating world stats by factor 10, by re-using stats object (#210) [v0.6.1] Documentation Extend documentation and benchmarks for Entity (#201) Add a section with links to the Arche tools arche-model and arche-pixel (#202) [v0.6.0] Arche v0.6.0 features fast batch entity creation and deletion, cached filters, and many internal optimizations.\nHighlights Batch creation and deletion of entities, with up to 4x and 10x speedup, respectively. Even more when combined with World.Reset(). Cached filters for handling many archetypes and complex queries without slowdown. A lot of internal performance optimizations. Breaking changes Generic mappers do no longer return all components when creating entities or components (#145) Resources API moved out of the world, to a helper to get by World.Resources() (#150) World.Reset() does no longer remove the component change listener (#157) Removes methods filter.ALL.Not() and filter.ANY.Not(), use NoneOf() and AnyNot() instead (#160) World listener function takes a pointer to the EntityEvent instead of a copy as argument (#162) Features Adds method World.Reset(), to allow for more efficient systematic simulations (#138) Adds World.Batch() helper for performing optimized batch-creation and batch-removal of entities (#149) Adds method Mask.Exclusive() to create a filter matching an exact component composition (#149, #188) Generic mappers (Map1, ‚Ä¶) have methods NewEntities, NewEntitiesWith and RemoveEntities for batch operations (#151) Batch-creation methods (ID-based and generic) have variants like NewEntitiesQuery that return a query over the created entities (#152) Notification during batch-creation is delayed until the resp. query is closed (#157) Batch-remove methods (RemoveEntities()) return the number of removed entities (#173) Filters can be cached and tracked by the World to speed up queries when there are many archetypes (#178) Function AddResource[T](*World) returns the ID of the resource (#183) Performance Speedup of archetype mask checks by 10% by checking mask before empty archetype (#139) Speedup of generic queries and mappers to come closer to ID-based access (#144) Speedup of archetype mask checks by casting filter interface to concrete type when possible (#148) Optimized batch creation of entities (#159) More efficiently clear the memory of removed components, with 2-3x speedup (#165) Do not clear memory when adding entities to archetypes, not required anymore as of #147 (#165) Speed up copying entity to archetype by getting entity pointer without reflection (#166) Avoid slice allocations in generic mapper methods (#170) Avoid type checks in query when iterating archetypes (#179) Speed up counting entities in queries with a cached filter (#182) Implements a fast and memory-efficient lookup data structure for components ID keys, to reduce the memory footprint of archetypes and the archetype graph (#192) Speedup of archetype creation by 40% by using a const for archetype storage page sizes (#197) Bugfixes Archetype storage buffers are ‚Äúzeroed‚Äù when removing entities, to allow GC on pointers and slices in components (#147) Use slices instead of arrays inside paged archetype list to ensure pointer persistence (#184) Documentation Adds an example for batch-creation and batch-removal of entities (#173) Adds code examples to most public types, methods and functions (#183, #189) Other Restructure and extend benchmarks (#146, #153, #155, #156) Add an ECS competition benchmark for adding and removing components (#170) Add benchmarks for different ways to implement parent-child relations between entities (#194, #195) [v0.5.1] Performance Speedup of archetype access by 5-10% by merging storages into archetypes (#137) Documentation Document all private functions, types and methods (#136) Adds a section and plot on benchmarks against other Go ECS implementations to the README (#138) Other Internal code refactoring (#136) Move method nextArchetype from World to Query. Remove internal type queryIter. Move repetitive pointer copying code in storage into a private method. Move repetitive entity creation code in World into a private method. [v0.5.0] Feature release. Does not break v0.4.x projects.\nFeatures The World handles ECS resources, i.e. component-like global data (#132) Generic access to world resources (#132) Documentation Adds an example for the use of resources (#132) [v0.4.6] Performance Speedup archetype access by 10%, by elimination of bounds checks (#126) Speedup entity access from queries by 50% by using a component storage for them (#131) Minor optimizations of component storage (#128) Documentation Adds an example to demonstrate how to implement classical ECS systems (#129) [v0.4.5] Features Adds memory per entity to archetype stats (#124) Other Adds benchmarks of Arche vs. Array of Structs (AoS) and Array of Pointers (AoP), for different memory per entity and number of entities (#123) [v0.4.4] Features Query has methods Count() and Step(int), primarily for effective random sampling (#119) Documentation Adds example random_sampling to demonstrate usage of Query.Count() and Query.Step(int) (#119) Bugfixes Query.Next, Query.Get, etc. now always panic when called on a closed query (#117) Other Update to go-gameengine-ecs v0.9.0 in benchmarks (#116) Remove internal wrapper structs in generic queries and maps (#120) [v0.4.3] Bugfixes EntityEvent has more consistent values when an entity is removed (#115) EntityEvent.NewMask is zero EntityEvent.Removed is contains all former components EntityEvent.Current is nil [v0.4.2] Performance Avoid creation of unused archetypes by splitting the archetype graph out of the actual archetypes (#113) Use slice instead of fixed-size array for type lookup in component registry (#113) Avoid copying entityIndex structs by using pointers (#114) [v0.4.1] Bugfixes Fix units symbol for bytes from b to B in string formatting of world statistics (#111) Other Adds github.com/wfranczyk/ento to benchmarks (#110) [v0.4.0] API revision, split out generics and filters into separate packages.\nFeatures Generic queries support optional, additional and excluded components (#53, #56, #58, #59, #60, #63) Logic filters for complex queries (#54, #58, #61) Query and World have a method Mask(Entity) to access archetype masks (#65) Generic query Get method returns all queried components (#83) Added method World.Stats() for inspecting otherwise inaccessible world statistics (#67) Entities can be initialized with components, via ID as well as using generics (#76) A listener function can be registered to the world, for notification on entity changes (#77) Support for up to 128 distinct component types per world (was limited to 64 before) (#78) Generic entity manipulation through types Map1, Map2, ‚Ä¶ and Exchange (#79, #84, #87) Performance Generic queries are compiled to masks and cached on first build (#62) Optimization of adding/removing components, with 2-3x speedup and vast reduction of (number of) allocations (#93) Speed up component world access by use of nil pointer check instead of bitmask (#96) Other Overhaul of the module structure, with generics and filters in separate packages (#55, #57, #61, #64) Boilerplate code for generic filters and queries is auto-generated with go generate (#64) Ensure 100% test coverage by adding a CI check for it (#68) World.RemEntity(Entity) is now World.RemoveEntity(Entity) (#87) More examples as user documentation (#83, #95) General API cleanup with renaming of several types and methods (#100) [v0.3.1] Other Fix failing https://pkg.go.dev to fetch Arche version v0.3.0 [v0.3.0] Features Added a layer of generic access as alternative for using component IDs, for type safety and ergonomics (#47, #48) Generic queries like Query1[T], Query2[T, U], ‚Ä¶ (#47) Generic add, assign and remove (Add[T](), Add2[T, U](), ...) (#47) Generic get, has, and set through component mapper Map[T] (#47) Performance Use of an archetype graph to speed up finding the target archetype for component addition/removal (#42) Minor optimization of component access by queries (#50) Other Reduced dependencies by moving profiling and benchmarking to sub-modules (#46) Smaller integer type for component identifiers (#47) [v0.2.0] Features World has method Exchange to add and remove components in one go (#38) World has method Assign add and assign components in one go (#38) World has method AssignN add and assign multiple components in one go (#38) Performance Optimization of Query iteration, avoids allocations and makes it approx. 30% faster (#35) Much smaller archetype data structure at the cost of one more index lookup (#37) Other Removed method Query.Count(), as it was a by-product of the allocations in the above point (#35) Archetypes are stored in a paged collection to use more efficient access by pointers (#36) [v0.1.4] Documentation Extended and improved documentation (#34) [v0.1.3] Features Add Config to allow for configuration of the world (currently only storage capacity increment) (#28) Query has a method Count(), reporting the total number of matching entities (#30) [v0.1.2] Other Use aligned item size in component storage for faster query iteration (#25) Queries lock the World, and automatically unlock it after iteration (#26) [v0.1.1] Other Avoid allocation in World.Has(entity, compID) (#16) World.RemEntity(entity) panics on dead entity, like all other World methods (#18) Reserve zero value Entity to serve as nil/undefined value (#23) [v0.1.0] Initial release.\nBasic ECS implementation.\n",
    "description": "Arche changelog.",
    "tags": null,
    "title": "Changelog",
    "uri": "/background/changelog/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†User Guide",
    "content": "So far, we stored all data in components, associated to entities. However, sometimes this is not optimal. This particularly applies to non-ECS data structures, and ‚Äúthings‚Äù that appear only once in a model or game.\nFor these cases, Arche provides so-called ecs.Resources . A resource can be thought of as a component that only appears once, globally, in an ecs.World .\nResource types Resource IDs Adding resources Accessing resources Resource types Just like with components, any Go struct (or other Go type) can be a resource. An example:\n1type Grid struct { 2 Data [][]ecs.Entity 3 Width int 4 Height int 5}Resource IDs Also analogous to components, resources are identified by a unique ID that can be obtained or registered using ecs.ResourceID :\n1world := ecs.NewWorld() 2 3gridID := ecs.ResourceID[Grid](\u0026world) 4_ = gridID As with components, a resource is registered and assigned an ID on first use automatically.\nAdding resources The most simple way to add a resource to the world is the function ecs.AddResource :\n1world := ecs.NewWorld() 2 3// Create the resource, and add a pointer to it to the world. 4grid := NewGrid(30, 20) 5ecs.AddResource(\u0026world, \u0026grid) An ID is automatically assigned to type Grid here, if it was not registered before with ecs.ResourceID .\necs.AddResource , however, is not particularly efficient. It a resource needs to be added (and removed) repeatedly, use ecs.World.Resources :\n1world := ecs.NewWorld() 2gridID := ecs.ResourceID[Grid](\u0026world) 3 4// Create the resource, and add a pointer to it to the world. 5grid := NewGrid(30, 20) 6world.Resources().Add(gridID, \u0026grid) Accessing resources Access to resources is obtained via ecs.World.Resources in the ID-based API, and via generic.Resource in the generic API:\n‚Äã generic ID-based 1world := ecs.NewWorld() 2 3// Create the resource, and add a pointer to it to the world. 4grid := NewGrid(30, 20) 5ecs.AddResource(\u0026world, \u0026grid) 6 7// Then, somewhere else in the code... 8gridRes := generic.NewResource[Grid](\u0026world) 9grid2 := gridRes.Get() 10 11_ = grid2.Data[1][2] 1world := ecs.NewWorld() 2 3// Create the resource, and add a pointer to it to the world. 4grid := NewGrid(30, 20) 5ecs.AddResource(\u0026world, \u0026grid) 6 7// Then, somewhere else in the code... 8gridID := ecs.ResourceID[Grid](\u0026world) 9grid2 := world.Resources().Get(gridID).(*Grid) 10 11_ = grid2.Data[1][2] Note that in the ID-based example, we need to cast the pointer retrieved from ecs.Resources.Get to *Grid, similar to the cast in ID-based component access. However, the syntax is a bit different here as we cast an interface{}, rather than an unsafe.Pointer for components.\nAs with components, the generic API is the recommended way for normal usage.\n",
    "description": "ECS resources in Arche.",
    "tags": null,
    "title": "ECS Resources",
    "uri": "/guide/resources/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†User Guide",
    "content": "Arche features an event system that can be used to get notifications about world modifications, namely:\nEntity creation and removal Component addition, removal and exchange Changes of entity relation targets The event system is particularly useful for automating the management of supplementary data structures that store entities. It can be used to automatically insert entities into these structures on creation or component addition, and to remove them on entity or component removal.\nThe types of interest here are ecs.Listener and ecs.EntityEvent .\nSubscriptions Builtin listener Custom listeners EntityEvent Subscriptions A listener must subscribe to certain event types. These are constants of type ecs.event.Subscription :\n1_ = event.EntityCreated 2_ = event.EntityRemoved 3_ = event.ComponentAdded 4_ = event.ComponentRemoved 5_ = event.RelationChanged 6_ = event.TargetChanged Multiple event types can be combined using bit-wise OR (|):\n1subs := event.EntityCreated | event.EntityRemoved 2_ = subs Some combinations of event types are already defined as ecs.event.Subscription . E.g., to subscribe to all event types, use event.All.\nBesides subscribing to event types, subscriptions can be restricted to certain component types that must be affected by the event. Component type subscriptions are realized using the same ecs.Mask mechanics that filters use. Create masks with ecs.All :\n1world := ecs.NewWorld() 2posID := ecs.ComponentID[Position](\u0026world) 3headID := ecs.ComponentID[Heading](\u0026world) 4 5compSubs := ecs.All(posID, headID) 6_ = compSubs A listener with this component subscription would be notified on changes that are related to the Position or to the Heading component.\nBuiltin listener An ecs.World can have at most one ecs.Listener . If required, this listener can be used to dispatch events to sub-listeners. Such a listener is provided by listener.Dispatch . In conjunction with listener.Callback , it is already possible to build a sophisticated event system.\nIn the following example, we compose a listener.Dispatch from two listener.Callback . The first one listens to all entity creation and entity removal events. The second one listens to events where a Position or a Heading is added to an entity.\n1world := ecs.NewWorld() 2posID := ecs.ComponentID[Position](\u0026world) 3headID := ecs.ComponentID[Heading](\u0026world) 4 5// Listener for all entity creation and entity removal events. 6entityListener := listener.NewCallback( 7\t// A function we want to call on notification. 8\tfunc(w *ecs.World, ee ecs.EntityEvent) { /* Do something here */ }, 9\t// Subscription to event types. 10\tevent.EntityCreated|event.EntityRemoved, 11) 12 13posOrHeadAddedListener := listener.NewCallback( 14\t// A function we want to call on notification. 15\tfunc(w *ecs.World, ee ecs.EntityEvent) { /* Do something here */ }, 16\t// Subscription to event types. 17\tevent.ComponentAdded, 18\t// Subscription is restricted to these component types. 19\tposID, headID, 20) 21 22// Create the dispatch listener from both sub-listeners. 23dispatch := listener.NewDispatch( 24\t\u0026entityListener, 25\t\u0026posOrHeadAddedListener, 26) 27// Set it as the world's listener. 28world.SetListener(\u0026dispatch) Custom listeners Custom listeners can be created by implementing the interface ecs.Listener . Here is an example of a listener that listens to additions of a Position component:\n1package main 2 3import ( 4\t\"fmt\" 5 6\t\"github.com/mlange-42/arche/ecs\" 7\t\"github.com/mlange-42/arche/ecs/event\" 8) 9 10// PositionAddedListener listens to additions of a Position component. 11type PositionAddedListener struct { 12\tsubs event.Subscription 13\tcomps ecs.Mask 14} 15 16// NewPositionAddedListener creates a new PositionAddedListener. 17func NewPositionAddedListener(world *ecs.World) PositionAddedListener { 18\tposID := ecs.ComponentID[Position](world) 19\treturn PositionAddedListener{ 20\tsubs: event.ComponentAdded, 21\tcomps: ecs.All(posID), 22\t} 23} 24 25// Notify the listener about a subscribed event. 26func (l *PositionAddedListener) Notify(world *ecs.World, evt ecs.EntityEvent) { 27\tfmt.Println(\"Position component added to entity \", evt.Entity) 28} 29 30// Subscriptions to one or more event types. 31func (l *PositionAddedListener) Subscriptions() event.Subscription { 32\treturn l.subs 33} 34 35// Components the listener subscribes to. Listening to all components indicated by nil. 36func (l *PositionAddedListener) Components() *ecs.Mask { 37\treturn \u0026l.comps 38} EntityEvent In Listener.Notify, as well as in the callback for listener.Callback , we get an ecs.EntityEvent as argument. It provides all sorts of information about the event, like the affected ecs.Entity , event types covered, components added and removed, and more. See the API docs of ecs.EntityEvent for details.\n",
    "description": "Arche's event system for entity modification.",
    "tags": null,
    "title": "Event System",
    "uri": "/guide/events/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†User Guide",
    "content": "Arche only exposes the API required for actual use. Therefore, internals like the number of archetypes, memory used to store components etc. are not directly accessible.\nHowever, it might sometimes be useful to have access to such metrics, for example in order to judge effects of different ways of implementing something. Otherwise, users would have to rely on logic reasoning and sufficient understanding of Arche to derive these numbers.\nFor that sake, Arche provides statistics about its internals, prepared in a compact and digestible form.\nAccessing statistics World stats Entity stats Node stats Archetype stats Accessing statistics All internal statistics can be accessed via ecs.World.Stats , which returns a *stats.World . This, in turn, contains the other stats types described below. All these types have a method String() to bring them into a compact, human-readable form.\n1world := ecs.NewWorld() 2 3builder := generic.NewMap2[Position, Heading](\u0026world) 4builder.NewBatch(100) 5 6stats := world.Stats() 7fmt.Println(stats) Which prints:\n1World -- Components: 2, Nodes: 3, Filters: 0, Memory: 7.0 kB, Locked: false 2 Components: Position, Heading 3Entities -- Used: 100, Recycled: 0, Total: 100, Capacity: 128 4Node -- Components: 0, Entities: 0, Capacity: 1, Memory: 0.0 kB, Per entity: 0 B 5 Components: 6Node -- Components: 2, Entities: 100, Capacity: 128, Memory: 4.0 kB, Per entity: 24 B 7 Components: Position, HeadingWorld stats stats.World provides world information like a list of all component types and the total memory reserved for entities and components. Further, it contains stats.Entities and a stats.Node for each active archetype node.\nEntity stats stats.Entities contains information about the entity pool, live capacity, alive entities and available entities for recycling.\nNode stats stats.Node provides information about an archetype node, like its components, memory in total and per entity, and more state information.\nFurther, it contains a stats.Archetype for each archetype.\nArchetype stats stats.Archetype contains size, capacity and memory information for an archetype.\n",
    "description": "Arche's world statistics feature for engine insights.",
    "tags": null,
    "title": "World Statistics",
    "uri": "/guide/stats/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†User Guide",
    "content": "Arche is highly optimized and can compete with mature ECS implementations in terms of performance. It will probably not get into your way in this regard. Experience shows that in simulation built with Arche, ECS code like queries, entity creation etc. takes between 5% and 15% of the total CPU time. Keep in mind that this is not ‚Äúon top‚Äù of the simulation, but replaces the overhead any other implementation for storing and iterating entities would have. Due to its cache-friendliness, archetype-based ECS can outperform e.g. an Array of Structs implementation, particularly for simulations with many entities and/or many variables per entity.\nNevertheless, each ECS has its strengths and weaknesses. This chapter provides tips on what you should pay attention to in order to get the most out of Arche.\nOptimized for Iteration Queries \u0026 Components Filter caching World access World operations Avoiding Multiple at once, Exchange Batching Optimized for Iteration Being an archetype-based ECS, Arche is optimized for queries and iteration. Adding and removing components is comparatively costly with this architecture, because components must be moved around between archetypes. The runtime difference between accessing a component and adding/removing a component is at least one order of magnitude. For some numbers for comparison, see the Benchmarks.\nQueries \u0026 Components The largest potential for optimizing queries is the clever design of components. The aim should be that queries access only data that is actually required, while at the same time reducing the amount of accessed components. Accessing fewer data means fewer cache misses, while accessing fewer components avoids lookups. To access only data that it actually required primarily means that the accessed components should contain only data that is used by the query.\nA component should only contain closely related data that is mostly or always accessed together. A Position component with X and Y is a good example. Vice versa, closely related data should be in the same component. What should be avoided are all-in-one components that mimic OOP classes to represent entities. A good (or rather, bad) example is a Tree component with X, Y, Biomass, Height, StemDiameter and LeaveAreaIndex (or more).\nFor fast memory access, the use of slices in components should be avoided. Use fixed-size arrays where possible.\nFilter caching When working with many archetypes, queries can be sped up by caching the underlying filter. This way, the filter is not checked against archetypes during query iteration. Instead, the archetypes relevant for the filter are cached, and checks are only required when new archetypes are created.\nFor details, see the section on caching in chapter Filters.\nWorld access World access to components with ecs.World.Get is per se slower than access through a query, as there is one more indirection and the alive status of the entity is checked for safety. Queries should be preferred over world access where possible.\nFurther, world access can‚Äôt benefit from the cache-friendly linearity of query iterations. This becomes more severe when the length of ‚Äújumps‚Äù between entities increases. Thus, is it more efficient to randomly access among e.g. 1000 entities compared to 100k entities.\nAs an example, say we have 1000 parent entities, 100k child entities, and don‚Äôt use Entity Relations. Here, it would be better to use a query over the children and access the parent of each child by world access. We jump around between 1000 entities. Alternatively, we could query the parents and access the children of each parent by world access. The number of accesses through the world would be the same, but we would jump between 100k entities, which would be slower.\nSee also the benchmarks for Entity Relations.\nWorld operations As explained above, operations like adding and removing components or creating entities are relatively costly in an archetype-based ECS. However, Arche provides some optimizations here, and following a few principles can help keeping the performance cost at a minimum.\nAvoiding Different components are a great way to represent different states of otherwise similar entities. For example, it is completely valid to build a finite state machine to model behavior, using components to represent states. However, each state transition results in moving an entity and its components between archetypes. Thus, when transitions occur frequently (say faster than every 20 ticks), different components are not the most efficient way to represent states. Alternatively, states could be represented by a variable in a single component, avoiding the overhead of moving entities between archetypes, at the cost of overhead in the queries.\nIt is a matter of weighting, and potentially benchmarking, to decide on what is represented by components in a query-able way, and what is left to be managed inside query loops.\nMultiple at once, Exchange As explained above, moving entities between archetypes is relatively costly. It is necessary when adding or removing components, but multiple components can be added or removed with a single transition between archetypes.\nFor that sake, methods like ecs.World.Add and ecs.World.Remove take an arbitrary number of component IDs as arguments. The generic API provides all types and functions for up to 12 components. Add or remove components together instead of one after another!\nFurther, ecs.World.Exchange and generic.Exchange allow to add some components and remove others at the same time. This also requires only a single transition between archetypes.\nBatching Arche provides batched variants of all operations like creating entities, adding and removing components, etc. Batching can speed up operations by up to an order of magnitude. It allows for bulk allocation of component memory and entities, and cuts off the overhead that is otherwise required for each entity, repeatedly. Entity creation is the most common use case for batching. For details, see the chapter on Batch Operations.\nSee also the Benchmarks for batched vs. un-batched operations.\n",
    "description": "Performance tips on how to get the most out of Arche.",
    "tags": null,
    "title": "Performance Tips",
    "uri": "/guide/performance/index.html"
  },
  {
    "breadcrumb": "Arche¬†\u003e¬†User Guide",
    "content": "A number of tools has been created for Arche.\nIf you wrote a tool and want it to be included here, please open an issue on GitHub.\narche-serde provides JSON serialization and deserialization for Arche‚Äôs World.\narche-model provides a wrapper around Arche, and some common systems and resources. its purpose is to get started with prototyping and developing simulation models immediately, focussing on the model logic.\narche-pixel provides OpenGL graphics and live plots for Arche using the Pixel game engine.\narche-demo provides examples of Arche models, which can be viewed in a live demo.\n",
    "description": "External tools built for Arche.",
    "tags": null,
    "title": "Tools",
    "uri": "/guide/tools/index.html"
  },
  {
    "breadcrumb": "",
    "content": " Arche is an archetype-based Entity Component System for Go.\nArche is designed for the use in simulation models of the Department of Ecological Modelling at the Helmholtz Centre for Environmental Research.\nArche‚Äôs Features Simple core API. See the API docs. Optional logic filter and type-safe generic API. Entity relations as first-class feature. See the User Guide. World serialization and deserialization with arche-serde. No systems. Just queries. Use your own structure (or the Tools). No dependencies. Except for unit tests (100% coverage). Probably the fastest Go ECS out there. See the Benchmarks. For more information, see the GitHub repository and API docs.\nCite as Lange, M. (2023): Arche ‚Äì An archetype-based Entity Component System for Go. DOI 10.5281/zenodo.7656484, GitHub repository: https://github.com/mlange-42/arche\nContributing Open an issue or start a discussion in the GitHub repository if you have questions, feedback, feature ideas or want to report a bug. Pull requests are welcome.\nLicense Arche and all its sources are released under the MIT License.\n",
    "description": "",
    "tags": null,
    "title": "Arche",
    "uri": "/index.html"
  },
  {
    "breadcrumb": "Arche",
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "Arche",
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
